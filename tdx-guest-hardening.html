

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Intel® Trust Domain Extension Guest Linux Kernel Hardening Strategy &mdash; Intel® Trust Domain Extension</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/table-wrap.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Intel® Trust Domain Extension Linux Guest Kernel Security Specification" href="security-spec.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Intel® Trust Domain Extension
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="security-spec.html">Intel® Trust Domain Extension Linux Guest Kernel Security Specification</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Intel® Trust Domain Extension Guest Linux Kernel Hardening Strategy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#purpose-and-scope">Purpose and Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hardening-strategy-overview">Hardening strategy overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#attack-surface-minimization">Attack surface minimization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#implemented-filtering-mechanisms">Implemented filtering mechanisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicitly-disabled-functionality">Explicitly disabled functionality</a></li>
<li class="toctree-l3"><a class="reference internal" href="#opt-in-shared-mmio-regions-pci-config-space-access">Opt-in shared MMIO regions &amp; PCI config space access</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#static-analyzer-and-code-audit">Static Analyzer and Code Audit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#requirements-and-goals">Requirements and goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#check-host-input-smatch-pattern">Check_host_input Smatch pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performing-a-manual-code-audit">Performing a manual code audit</a></li>
<li class="toctree-l3"><a class="reference internal" href="#applying-code-audit-results-to-different-kernel-trees">Applying code audit results to different kernel trees</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#td-guest-fuzzing">TD Guest Fuzzing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tdx-emulation-setup">TDX emulation setup</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#implementation-details">Implementation details</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fuzzing-kernel-boot">Fuzzing Kernel Boot</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#agent">Agent</a></li>
<li class="toctree-l3"><a class="reference internal" href="#harnesses-definition">Harnesses Definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-workflow">Example Workflow</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setup-instructions">Setup Instructions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fuzzing-kernel-runtime">Fuzzing Kernel Runtime</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fuzzing-stimulus">Fuzzing Stimulus</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-fuzzer-hooks">Simple Fuzzer Hooks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kf-x-dma-fuzzing">KF/x DMA Fuzzing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#details">Details</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">Setup instructions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kafl-stimulus-fuzzing">kAFL Stimulus Fuzzing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#harness-setup">Harness Setup</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#enabling-additional-kernel-drivers">Enabling additional kernel drivers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#identify-the-device-driver-pair">Identify the device/driver pair</a></li>
<li class="toctree-l3"><a class="reference internal" href="#perform-code-audit">Perform code audit</a></li>
<li class="toctree-l3"><a class="reference internal" href="#perform-driver-fuzzing">Perform driver fuzzing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#perform-code-fixes">Perform code fixes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#enable-driver-in-the-tdx-filter">Enable driver in the TDX filter</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Intel® Trust Domain Extension</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Intel® Trust Domain Extension Guest Linux Kernel Hardening Strategy</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/tdx-guest-hardening.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="intel-trust-domain-extension-guest-linux-kernel-hardening-strategy">
<span id="tdx-guest-hardening"></span><h1>Intel® Trust Domain Extension Guest Linux Kernel Hardening Strategy<a class="headerlink" href="#intel-trust-domain-extension-guest-linux-kernel-hardening-strategy" title="Permalink to this heading">¶</a></h1>
<p>Contributors:</p>
<p>Elena Reshetova, Tamas Lengyel, Sebastian Osterlund, Steffen Schulz</p>
<section id="purpose-and-scope">
<h2>Purpose and Scope<a class="headerlink" href="#purpose-and-scope" title="Permalink to this heading">¶</a></h2>
<p>The main security goal of Intel® Trust Domain Extension (Intel® TDX)
technology is to remove the need for a guest VM to trust the host and
Virtual Machine Manager (VMM). However, it cannot by itself protect the
guest VM from host/VMM attacks that leverage existing paravirt-based
communication interfaces between the host/VMM and the guest, such as
MMIO, Port IO, etc. To achieve protection against such attacks, the guest
VM software stack needs to be hardened to securely handle an untrusted
and potentially malicious input from a host/VMM via the above-mentioned
interfaces. This hardening effort should be applied to a concrete set of
software components that are used within the guest software stack
(virtual BIOS, bootloader, Linux* kernel and userspace), which is
specific to a concrete deployment scenario. To facilitate this process,
we have developed a hardening methodology and tools that are explained
below.</p>
<p>The hardening approach presented in this document is by no means an
ultimate guarantee of 100% security against the above-mentioned attacks,
but merely a methodology built to our best knowledge and resource
limitations. In our environment, we have successfully applied it to the
Linux TDX MVP software stack (<a class="reference external" href="https://github.com/intel/tdx-tools">https://github.com/intel/tdx-tools</a>)
to the trust domain (TD) guest Linux kernel and hardened many involved
kernel subsystems. This guide is written with the Linux kernel in mind,
but the outlined principles can be applied to any software component.</p>
<p>The overall threat model and security architecture for the TD guest
kernel is described in the <a class="reference internal" href="security-spec.html#security-spec"><span class="std std-ref">Intel® Trust Domain Extension Linux Guest Kernel Security Specification</span></a> and it is
recommended to be read together with this document.</p>
</section>
<section id="hardening-strategy-overview">
<h2>Hardening strategy overview<a class="headerlink" href="#hardening-strategy-overview" title="Permalink to this heading">¶</a></h2>
<p>The overall hardening strategy shown in Figure 1 encompasses three
activities that are executed in parallel: attack surface minimization,
manual code audit, and code fuzzing. All of them are strongly linked and
the results from each activity are contributed as inputs to the other
activities. For example, the results of a manual code audit can be used
to decide whenever a certain feature should be disabled (attack surface
minimization) or should be a target for a detailed fuzzing campaign.
Similarly, the fuzzing results might affect the decision to disable a
certain functionality or indicate a place where a manual code audit is
required but have been missed by a static code analyzer.</p>
<figure class="align-default" id="id7">
<a class="reference internal image-reference" href="_images/strategy.png"><img alt="_images/strategy.png" src="_images/strategy.png" style="width: 5.51418in; height: 3.23958in;" /></a>
<figcaption>
<p><span class="caption-text">Figure 1. Linux Guest kernel hardening strategy.</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The following section provides a detailed description of each of these
activities. An overall crucial aspect to consider is the “definition of
done”, i.e., the criteria for when a hardening effort can be finished
and how the success of such effort is defined.</p>
<p>The ideal “definition of done” criteria can be outlined as follows:</p>
<ol class="arabic simple">
<li><p>The guest kernel functionality and the VMM/host exposed interfaces
are limited to the minimum required for its successful operation,
given a chosen deployment scenario. This implies that only a minimal
set of required drivers, kernel subsystems, and individual
functionality is enabled.</p></li>
<li><p>All code paths that are enabled within the guest kernel and can take
an untrusted input from VMM/host must be manually audited from the
potential consequences of consuming the malformed data. Whenever a
manual code audit identifies an issue that is a security concern, it
must be addressed either by a bug fix or by disabling the involved
code path, if possible.</p></li>
<li><p>All code paths that are enabled within the guest kernel and can take
an untrusted input from VMM/host must be fuzzed using an appropriate
fuzzing technique. The fuzzing technique must provide the coverage
information to identify that a fuzzer has reached the required code
paths and exercised them sufficiently. Whenever the fuzzing activity
identifies an issue that is a security concern, it must be addressed
either by a bug fix or by disabling the involved code path.</p></li>
</ol>
<p>The success of the overall hardening effort is significantly more
difficult to measure. The total number of security concerns identified
by the manual code audit or fuzzing activity is a natural quantifier,
but it neither guarantees that the end goal of having a secure guest
kernel has been successfully reached nor does it necessarily indicate
that the chosen hardening approach is successful. The successful
operation of the guest kernel within the Linux TD software stack and the
absence of issues identified or reported during its deployment life cycle
is a much stronger, albeit a post-factum indicator.</p>
</section>
<section id="attack-surface-minimization">
<h2>Attack surface minimization<a class="headerlink" href="#attack-surface-minimization" title="Permalink to this heading">¶</a></h2>
<p>The main objective for this task is to disable as much code as possible
from the TD guest kernel to limit the number of interfaces exposed to
the malicious host/VMM. This is achieved by either explicitly disabling
certain unneeded features (for example early PCI code), by a generic
filtering approach, such as port IO filtering, driver filtering, etc or
by restricting access to the MMIO and PCI config space regions</p>
<section id="implemented-filtering-mechanisms">
<h3>Implemented filtering mechanisms<a class="headerlink" href="#implemented-filtering-mechanisms" title="Permalink to this heading">¶</a></h3>
<p>All the implemented filtering mechanisms described below are runtime
mechanisms that limit TD guest functionality based on a set of default
allow lists defined in the kernel source code, but with a possibility to
override these defaults via a command line option mechanism. The latter
can be used for debugging purposes or for enabling a specific driver,
ACPI table, or KVM CPUID functionality that is required for a particular
deployment scenario.</p>
<table class="docutils align-default" id="id8">
<caption><span class="caption-text">Filter status</span><a class="headerlink" href="#id8" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Filter name</p></th>
<th class="head"><p>Purpose and current state</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Driver filter</p></td>
<td><p>Limits a set of drivers that are enabled in runtime for the TD guest kernel.
By default, all PCI and ACPI bus drivers are blocked unless they are in the allow
list. The current default allow list for the PCI bus is limited to the
following virtio drivers: virtio_net, virtio_console, virtio_blk, and
9pnet_virtio.</p></td>
</tr>
<tr class="row-odd"><td><p>Port IO filter</p></td>
<td><p>Limits a set of IO ports that can be used for communication between a TD
guest kernel and the host/VMM. This feature is needed in addition to the
above driver filtering mechanism, because should some drivers escape this
mechanism, its port IO communication with the host/VMM will be limited to a
small set of allowed ports. For example, some linux drivers might perform
port IO reads in their initialization functions before doing the driver
registration or some legacy drivers might not utilize the modern driver
registration interface at all and therefore would be allowed by the above
driver filter. In any case port IO filter makes sure that only a limited
number of ports are allowed to be communicating with host/VMM. The port IO
allow list can be found in <a class="reference internal" href="security-spec.html#sec-io-ports"><span class="std std-ref">IO ports</span></a>.
Note that in the decompressed mode, the port IO
filter is not active and therefore it is only applicable for early port IO
and normal port IO.</p></td>
</tr>
<tr class="row-even"><td><p>ACPI table allow list</p></td>
<td><p>TDX virtual firmware (TDVF, for details see
<a class="reference external" href="https://www.intel.com/content/dam/develop/external/us/en/documents/tdx-virtual-firmware-design-guide-rev-1.pdf">https://www.intel.com/content/dam/develop/external/us/en/documents/tdx-virtual-firmware-design-guide-rev-1.pdf</a>)
measures a set of ACPI tables obtained from the host/VMM into TDX RTMR[
0] measurement register. Thus, the set of tables passed by the host/VMM can
be remotely attested and verified. However, it can be difficult for a
remote verifier to understand the possible consequences from using a big
set of various ACPI tables. Since most of the tables are not needed for a
TDX guest, the implemented ACPI table allow list limits them to a small,
predefined list with a possibility to pass additional tables via a command
line option. The current allow list is limited to the following tables:
XSDT, FACP, DSDT, FACS, APIC, and SVKL. Note that a presence of a minimal
ACPI table configuration does not by itself guarantee the overall security
hardening of ACPI subsystem in the TD guest kernel. The known limitations
on ACPI hardening are described in <a class="reference internal" href="security-spec.html#sec-acpi-tables"><span class="std std-ref">BIOS-supplied ACPI tables and mappings</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>KVM CPUID allow list and KVM hypercalls</p></td>
<td><p>KVM supports a set of hypercalls that a TD guest kernel can request a VMM to
perform. On x86, this set is defined by a set of exposed CPUID bits. Some
of the hypercalls can result in untrusted data being passed from a VMM
KVM) to the guest kernel. To limit this attack vector, the implemented KVM
CPUID allow list restricts the available KVM CPUID bits to a small
predefined allow list. More information can be found in
<a class="reference internal" href="security-spec.html#sec-kvm-hypercalls"><span class="std std-ref">KVM CPUID features and Hypercalls</span></a> and <span class="xref std std-ref">sec-kvm-cpuid</span>.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="explicitly-disabled-functionality">
<h3>Explicitly disabled functionality<a class="headerlink" href="#explicitly-disabled-functionality" title="Permalink to this heading">¶</a></h3>
<p>Most of the functionality described below takes an untrusted host input
via MSR, port IO, MMIO, or pci config space reads through its codebase.
This has been identified using the static code analyzer described in the
next section. The decision to disable this functionality was made based
on the amount of code that would have to be manually audited, complexity
of the code involved, as well as the fact that this functionality is not
needed for the TD guest kernel.</p>
<table class="docutils align-default" id="id9">
<caption><span class="caption-text">Features</span><a class="headerlink" href="#id9" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 80.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Feature type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>x86 features</p></td>
<td><p>Some x86 feature bits are explicitly cleared out by the TD guest kernel
during an initialization, such as X86_FEATURE_MCE, X86_FEATURE_MTRR,
X86_FEATURE_TME, X86_FEATURE_APERFMPERF, X86_FEATURE_CQM_LLC.</p></td>
</tr>
<tr class="row-odd"><td><p>Various PCI functionality</p></td>
<td><p>Some PCI related functionality that is not needed in the TD guest kernel is
also explicitly disabled, such as early PCI, PCI quirks, and enhanced PCI
parsing.</p></td>
</tr>
<tr class="row-even"><td><p>Miscellaneous</p></td>
<td><p>A malicious host/VMM can fake PCI ids or some CPUID leaves to enable
functionality that is normally disabled for a TDX guest and therefore not
hardened. To help prevent this from happening, support for XEN, HyperV, and ACRN
hypervisors, as well as AMD northbridge support, is explicitly disabled in
the TD guest kernel.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="opt-in-shared-mmio-regions-pci-config-space-access">
<h3>Opt-in shared MMIO regions &amp; PCI config space access<a class="headerlink" href="#opt-in-shared-mmio-regions-pci-config-space-access" title="Permalink to this heading">¶</a></h3>
<p>To further minimize the amount of code that needs to be hardened, we
require the TD guest kernel to explicitly opt-in any MMIO region that
needs to be shared with the host. This ensures that there is no
accidental shared MMIO regions created in the TD guest kernel that can
escape the hardening. A similar requirement applies to the PCI config
space accesses: only authorized devices are allowed to perform PCI
config space reads (this applies even to the PCI config space done from
the device initialization routine).</p>
</section>
</section>
<section id="static-analyzer-and-code-audit">
<span id="hardening-smatch-report"></span><h2>Static Analyzer and Code Audit<a class="headerlink" href="#static-analyzer-and-code-audit" title="Permalink to this heading">¶</a></h2>
<section id="requirements-and-goals">
<h3>Requirements and goals<a class="headerlink" href="#requirements-and-goals" title="Permalink to this heading">¶</a></h3>
<p>The attack surface minimization activity outlined in the previous
section helps to limit the amount of TD guest kernel code that actively
interacts with the untrusted host/VMM. It is not possible to fully
remove this interaction due to the functional requirements that the TD
guest has; it needs to be able to perform network communication, it
should be possible to interact with the TD guest via console, etc. Thus,
we need to be able to manually audit all the TD guest kernel enabled
code that consumes an untrusted input from the host/VMM to ensure it
does not use this input in an unsecure way.</p>
<p>To perform a more focused manual code audit, the exact locations where
the untrusted host input is consumed by the TD guest kernel needs to be
identified automatically. We have defined the following requirements for
this process:</p>
<ol class="arabic simple">
<li><p><strong>Adjustability of custom kernel trees.</strong> The method must be easy to
use on any custom kernel tree with any set of applied patches and
specified kernel configuration.</p></li>
<li><p><strong>Absence of code instrumentation.</strong> The expected number of locations
where the TD guest can take an untrusted input from the host goes
well beyond 1500 places even after the functionality minimization
step. This makes it impossible to manually instrument these
locations, as well as keep maintaining the instrumentation through
the kernel version changes, custom patch sets, etc.</p></li>
<li><p><strong>Open-source well established tool</strong>. The tool should be easily
accessible for open source and for the kernel community to use and
should be actively maintained and supported.</p></li>
</ol>
</section>
<section id="check-host-input-smatch-pattern">
<h3>Check_host_input Smatch pattern<a class="headerlink" href="#check-host-input-smatch-pattern" title="Permalink to this heading">¶</a></h3>
<p>Based on the above requirements, a Smatch static code analyzer
(<a class="reference external" href="http://smatch.sourceforge.net/">http://smatch.sourceforge.net/</a>) has
been chosen since it provides an easy interface to write custom patterns
to search for problematic locations in the kernel source tree. Smatch
already has a big set of existing patterns that have been used to find
many security issues with the current mainline kernel.</p>
<p>To identify the locations where a TD guest kernel can take an untrusted
input from the host/VMM, a custom Smatch pattern
<a class="reference external" href="https://repo.or.cz/smatch.git/blob/HEAD:/check_host_input.c">check_host_input</a>
has been written.
It operates based on a list of base “input functions” (contained
in <a class="reference external" href="https://repo.or.cz/smatch.git/blob/HEAD:/smatch_kernel_host_data.c">smatch_kernel_host_data</a>),
i.e. low-level
functions that perform MSR, port IO, and MMIO
reads, such as native_read_msr, inb/w/l, readb/w/l, as well as
higher-level wrappers specific to certain subsystems. For example, PCI
config space uses many wrappers like pci_read_config,
pci_bus/user_read_* through its code paths to read the information
from the untrusted host/VMM. Whenever a function listed in
<a class="reference external" href="https://repo.or.cz/smatch.git/blob/HEAD:/smatch_kernel_host_data.c">smatch_kernel_host_data</a>
is detected in the code, the correct parameters (containing an input that
could have been supplied by the host) are marked as ‘host_data’ and
Smatch’s taint analysis will perform propagation of this data through
the whole kernel codebase. The output of the check_host_input
pattern when run against the whole kernel tree is a list of all locations
in kernel where the ‘host_data’ is being processed, with exact code locations
and some additional information to assist the manual code audit process.</p>
<p>Additionally existing smatch patterns can take a benefit from the fact
that ‘host_data’ is now correctly tracked. For example, a modified
<a class="reference external" href="https://repo.or.cz/smatch.git/blob/HEAD:/check_spectre.c">check_spectre</a>
Smatch pattern now is able to detect spectre v1 gadgets not only on the
userspace &lt;-&gt;kernel surface, but also host &lt;-&gt;guest surface. More
information can be found in <a class="reference external" href="https://intel.github.io/ccc-linux-guest-hardening-docs/security-spec.html#transient-execution-attacks-and-their-mitigation">Transient Execution attacks and their mitigation</a></p>
<p>The current approach using the check_host_input Smatch pattern has
several limitations. The main limitation is the importance of having a
correct list of input functions since the pattern will not detect the
invocations of functions not present in this list. Fortunately, the
low-level base functions for performing MSR, port IO, and MMIO read
operations are well-defined in the Linux kernel. Another limitation of
this approach is the inability to detect generic DMA-style memory accesses, since they
typically do not use any specific functions or wrappers to receive the
data from the host/VMM. An exception here is a virtIO ring subsystem
that uses virtio16/32/64_to_cpu wrappers in most of the places to
access memory locations residing in virtIO ring DMA pages. The
invocation of these wrappers can be detected by the check_host_input
Smatch pattern and the findings can be reported similarly as for other
non-DMA accesses.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>arch/x86/pci/irq.c:1201<span class="w"> </span>pirq_enable_irq<span class="o">()</span><span class="w"> </span>warn:
<span class="o">{</span><span class="m">9123410094849481700</span><span class="o">}</span><span class="nb">read</span><span class="w"> </span>from<span class="w"> </span>the<span class="w"> </span>host<span class="w"> </span>using<span class="w"> </span><span class="k">function</span>
<span class="s1">&#39;pci_read_config_byte&#39;</span><span class="w"> </span>to<span class="w"> </span>an<span class="w"> </span>int<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="nb">local</span><span class="w"> </span>variable<span class="w"> </span><span class="s1">&#39;pin&#39;</span>,<span class="w"> </span><span class="nb">type</span><span class="w"> </span>is
uchar<span class="p">;</span>

arch/x86/pci/irq.c:1216<span class="w"> </span>pirq_enable_irq<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">11769853683657473858</span><span class="o">}</span>Propagating<span class="w"> </span>an<span class="w"> </span>expression<span class="w"> </span>containing<span class="w"> </span>a<span class="w"> </span>tainted
value<span class="w"> </span>from<span class="w"> </span>the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;pin - 1&#39;</span><span class="w"> </span>into<span class="w"> </span>a<span class="w"> </span><span class="k">function</span>
<span class="s1">&#39;IO_APIC_get_PCI_irq_vector&#39;</span><span class="p">;</span>

arch/x86/pci/irq.c:1228<span class="w"> </span>pirq_enable_irq<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">15187152360757797804</span><span class="o">}</span>Propagating<span class="w"> </span>a<span class="w"> </span>tainted<span class="w"> </span>value<span class="w"> </span>from<span class="w"> </span>the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;pin&#39;</span>
into<span class="w"> </span>a<span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="s1">&#39;pci_swizzle_interrupt_pin&#39;</span><span class="p">;</span>

arch/x86/pci/irq.c:1229<span class="w"> </span>pirq_enable_irq<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">8593519367775469163</span><span class="o">}</span>Propagating<span class="w"> </span>an<span class="w"> </span>expression<span class="w"> </span>containing<span class="w"> </span>a<span class="w"> </span>tainted
value<span class="w"> </span>from<span class="w"> </span>the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;pin - 1&#39;</span><span class="w"> </span>into<span class="w"> </span>a<span class="w"> </span><span class="k">function</span>
<span class="s1">&#39;IO_APIC_get_PCI_irq_vector&#39;</span><span class="p">;</span>

arch/x86/pci/irq.c:1233<span class="w"> </span>pirq_enable_irq<span class="o">()</span><span class="w"> </span>warn:
<span class="o">{</span><span class="m">3245640912980979571</span><span class="o">}</span>Propagating<span class="w"> </span>an<span class="w"> </span>expression<span class="w"> </span>containing<span class="w"> </span>a<span class="w"> </span>tainted
value<span class="w"> </span>from<span class="w"> </span>the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;65 + pin - 1&#39;</span><span class="w"> </span>into<span class="w"> </span>a<span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="s1">&#39;_dev_warn&#39;</span><span class="p">;</span>

arch/x86/pci/irq.c:1243<span class="w"> </span>pirq_enable_irq<span class="o">()</span><span class="w"> </span>warn:
<span class="o">{</span><span class="m">11844818720957432302</span><span class="o">}</span>Propagating<span class="w"> </span>an<span class="w"> </span>expression<span class="w"> </span>containing<span class="w"> </span>a<span class="w"> </span>tainted
value<span class="w"> </span>from<span class="w"> </span>the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;65 + pin - 1&#39;</span><span class="w"> </span>into<span class="w"> </span>a<span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="s1">&#39;_dev_info&#39;</span><span class="p">;</span>

arch/x86/pci/irq.c:1262<span class="w"> </span>pirq_enable_irq<span class="o">()</span><span class="w"> </span>warn:
<span class="o">{</span><span class="m">14811741117821484023</span><span class="o">}</span>Propagating<span class="w"> </span>an<span class="w"> </span>expression<span class="w"> </span>containing<span class="w"> </span>a<span class="w"> </span>tainted
value<span class="w"> </span>from<span class="w"> </span>the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;65 + pin - 1&#39;</span><span class="w"> </span>into<span class="w"> </span>a<span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="s1">&#39;_dev_warn&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>Figure 2. Sample output from the check_host_input Smatch pattern.</p>
<p>The sample output of the check_host_input Smatch pattern is shown on
Figure 2. The function pirq_enable_irq performs a PCI config space
read operation using a pci_read_config_byte input function (PCI
config space specific higher-level wrapper) and stores the result in the
local variable pin (type uchar). Next, this local variable is being
supplied as an argument to the IO_APIC_get_PCI_irq_vector and
pci_swizzle_interrupt_pin functions, as well as to several
_dev_info/warn functions. The relevant code snippet with highlighted
markings is shown in Figure 3.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/code-snipped-pirq.png"><img alt="_images/code-snipped-pirq.png" src="_images/code-snipped-pirq.png" style="width: 6.14865in; height: 5.68750in;" /></a>
</figure>
<p>Figure 3. Code snippet for the pirq_enable_irq function.</p>
</section>
<section id="performing-a-manual-code-audit">
<span id="hardening-performing-manual-audit"></span><h3>Performing a manual code audit<a class="headerlink" href="#performing-a-manual-code-audit" title="Permalink to this heading">¶</a></h3>
<p>The check_host_input Smatch pattern can be run as any other existing
smatch patterns following instructions in <a class="reference external" href="https://repo.or.cz/smatch.git/blob/HEAD:/Documentation/smatch.txt">Smatch documentation</a> .
One important precondition before running the pattern is to build the smatch cross
function database first (at least 5-6 times) in order to make sure that
the database contains the propagated taint data. The database pre-build step needs
to happen only once per kernel tree and is not needed in the subsequent
analysis runs. Also, since the pattern is automatically disabled in the smatch
default configuration (due to a significant volume output), it must be explicitly
enabled in the <a class="reference external" href="https://repo.or.cz/smatch.git/blob/HEAD:/check_list.h#l232">smatch header file</a>
before performing an audit run.</p>
<p>The <a class="reference external" href="https://github.com/intel/ccc-linux-guest-hardening/blob/master/docs/generate_smatch_audit_list.md">ccc-linux-guest-hardening repository</a>
contains instructions on how to obtain the output of check_host_input smatch pattern
using automated scripts provided with the repository.
Internally, when a manual code audit activity is performed, the list of overall
findings is filtered using the process_smatch_output.py python
script to discard the results for the areas that are disabled within the
TD guest kernel. For example, most of the drivers/* and sound/*
results are filtered out except for the drivers that are enabled in the
TD guest kernel. Additionally, process_smatch_output.py also discards
findings from other enabled by default smatch patterns.</p>
<p>After following instructions in <a class="reference external" href="https://github.com/intel/ccc-linux-guest-hardening/blob/master/docs/generate_smatch_audit_list.md">ccc-linux-guest-hardening repository</a> the reduced list of smatch
pattern findings, smatch_warns.txt, can be analyzed
manually by looking at each reported code location and verifying that
the consumed or propagated host input is used in a secure way.</p>
<p>Each finding is therefore manually classified into one of the following
statuses:</p>
<table class="docutils align-default" id="id10">
<caption><span class="caption-text">Findings</span><a class="headerlink" href="#id10" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 80.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Status</strong></p></th>
<th class="head"><p><strong>Meaning</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>excluded</p></td>
<td><p>This code location is not reachable inside a TD guest due to it being
non-Intel code or functionality that is disabled for the TD guest kernel.
The reason these lines are not filtered from the Smatch report by the above
process_smatch_output.py python script is additional checks that we do
when executing the fuzzing activity described in the next section. We
perform an additional verification that none of these excluded code
locations can be reached by the fuzzer.</p></td>
</tr>
<tr class="row-odd"><td><p>unclassified</p></td>
<td><p>This code location is reachable inside TDX guest (i.e. not excluded), but
has not been manually audited yet.</p></td>
</tr>
<tr class="row-even"><td><p>wrapper</p></td>
<td><p>The function that consumes or propagates a host input is a higher-level wrapper. The
function is being checked for processing the host input in a secure way,
but additionally all its callers are also reported by the Smatch pattern
and the code audit happens on each caller.</p></td>
</tr>
<tr class="row-odd"><td><p>trusted</p></td>
<td><p>The consumed input comes from a trusted source for Intel TDX guest, i.e.
it is provided by the TDX module or context-switched for every TDX guest
(i.e. native). This is applicable for both MSRs and CPUIDs. More information
can be found in <a class="reference internal" href="security-spec.html#sec-msrs"><span class="std std-ref">MSRs</span></a> and <a class="reference internal" href="security-spec.html#sec-cpuids"><span class="std std-ref">CPUID</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p>safe</p></td>
<td><p>The consumed or propagated host input looks to be used in a secure way</p></td>
</tr>
<tr class="row-odd"><td><p>concern</p></td>
<td><p>The consumed or propagated host input is used in an unsecure way. There is an additional
comment indicating the exact reason. All concern items must be addressed
either by disabling the code that performs the host input processing or by
writing a patch that fixes the problematic input processing.</p></td>
</tr>
</tbody>
</table>
<p>The main challenge in this process is a decision whenever a certain
reported code location is considered “safe” or “concern”. The typical
list of “concern” items can be classified into two categories:</p>
<ol class="arabic simple">
<li><p><strong>Memory access issues</strong>. A host input is being used as an address,
pointer, buffer index, loop iterator bound or anything else that
might result in the host/VMM being able to have at least partial
control over the memory access that a TD guest kernel performs.</p></li>
<li><p><strong>Conceptual security issues.</strong> A host input is being used to affect
the overall security of the TD guest or its features. An example is
when an untrusted host input is used for operating TD guest clock or
affecting KASLR randomization.</p></li>
</ol>
</section>
<section id="applying-code-audit-results-to-different-kernel-trees">
<h3>Applying code audit results to different kernel trees<a class="headerlink" href="#applying-code-audit-results-to-different-kernel-trees" title="Permalink to this heading">¶</a></h3>
<p>The provided <a class="reference external" href="https://github.com/intel/ccc-linux-guest-hardening/blob/master/bkc/audit/sample_output/6.0-rc2/smatch_warns_6.0_tdx_allyesconfig_filtered_analyzed">sample audit output</a>
of check_host_input smatch pattern findings for the version 6.0-rc2 kernel
contains results of our manual code audit activity for this kernel version
(Please note that the above provided list
does not have ‘safe’ or ‘concern’ markings published) and
can be used as a baseline for performing a manual audit on other kernel
versions or on custom vendor kernels. The suggested procedure to analyse
a custom kernel is documented in ‘Targeting your own guest kernel’[TBD].</p>
<p>The automatic transfer of the code audit labels (trusted, excluded,
wrapper, etc.) from the baseline kernel audit version is  based on the
unique identifiers for each finding. Examples of these findings are
shown in orange in Figure 2. Identifiers from a baseline kernel tree
finding and target tree finding must match for a finding to be
automatically transferred. An identifier is a simple djb2 hash of
an analyzed code expression together with a relative offset from the
beginning of the function where this expression is located. It is
possible to further improve the calculation of identifiers (and
therefore improve the accuracy of automatic result transfer) to include
the code around the expression in a way that it is done in various
version control systems, but it has not been done yet.</p>
</section>
</section>
<section id="td-guest-fuzzing">
<h2>TD Guest Fuzzing<a class="headerlink" href="#td-guest-fuzzing" title="Permalink to this heading">¶</a></h2>
<p>Fuzzing is a well-established software validation technique that can be
used to find problems in input handling of various software components.
In our TD guest kernel hardening project, we used it to validate and
cross check the results from the manual code audit activity.</p>
<p>The main goals for the fuzzing activity are:</p>
<ol class="arabic simple">
<li><p>Automatically exercise the robustness of the existing TD guest kernel
code that was identified by the Smatch pattern as handling the input
from the host/VMM.</p></li>
<li><p>Identify new TD guest kernel code locations that handle the input
from the host/VMM and were missed by the Smatch pattern (for example
some virtIO DMA accesses). When such locations are identified, the
Smatch pattern can be further improved to catch these and similar
places in other parts of the kernel code.</p></li>
<li><p>Automatically verify that the code that is expected to be disabled in
the TD guest kernel (and thus not manually audited at all) is indeed
not executed/not reachable in practice.</p></li>
</ol>
<p>The primary ways of consuming untrusted host/VMM is by using either TDVMCALLs or
DMA shared memory as used for example by the VirtIO layer. Additionally, the
code paths that consume untrusted input may invoked automatically during boot,
or require some additional stimulus to execute during runtime.</p>
<p>In the following we review options we considered for generating potential
relevant userspace activity and fuzzing the various relevant input interfaces
during boot as well as during runtime.</p>
</section>
<section id="tdx-emulation-setup">
<h2>TDX emulation setup<a class="headerlink" href="#tdx-emulation-setup" title="Permalink to this heading">¶</a></h2>
<p>Running a fully functional TDX guest requires CPU and HW support that is only
available on future Intel Xeon platforms. On contrary, our TDX
emulation setup allows testing SW running inside TDX guest VM early on ahead of
HW availability. It can be run on any recent and commonly available Intel
platforms without any special HW features. However, it is important to note that
this emulation setup is very limited in the amount of features it supports
and is not secure: emulated TDX guest runs under full control of the host
and VMM.</p>
<p>The main challenge for the setup is the emulation of the Intel TDX module.
Intel TDX module is a special SW module that plays a role of a secure shim between
the TDX host and TDX guest and provides an extensive API towards both VMM and TDX guest.
However, since our goal is only fuzzing of the TDX guest kernel,
we need a minimal emulation of the TDX Seam module that can support the basic set
of calls that TDX guest does towards the TDX module,
as well as wrapping such calls into existing kvm interfaces.
For more details about the actual Intel TDX module and its functionality please see
<a class="reference external" href="https://www.intel.com/content/dam/develop/external/us/en/documents/tdx-module-1.0-public-spec-v0.931.pdf">Intel TDX module architecture specification</a></p>
<section id="implementation-details">
<h3>Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this heading">¶</a></h3>
<p>The TDX emulation setup is implemented as a simple Linux kernel module with the
code in arch/x86/kvm/vmx/seam.c. Whenever the core TDX code in KVM performs
basic lifecycle operations on the TDX guest (initialization, startup, destruction,
etc.) it would call the respected functions in the TDX emulation setup (seam_tdcreatevp,
seam_tdinitvp/tdfreevp, seam_tdenter, etc.) instead of the actual TDX functions.
The emulated seam module supports a minimal set of exit reasons from the TDX guest
(including EXIT_REASON_TDCALL, EXIT_REASON_CPUID, EXIT_REASON_EPT_VIOLATION) and
inserts a #VE exception into an emulated TDX guest when the guest performs
operations on MSRs, CPUIDs, portIO and MMIO, as well as on guest’s EPT violations.
Emulation performed by the TDX emulation setup is currently not exact but mainly focused
on exercising and testing the relevant TDX support by the guest OS.
Please refer to section 24 of
<a class="reference external" href="https://www.intel.com/content/dam/develop/external/us/en/documents/tdx-module-1.0-public-spec-v0.931.pdf">Intel TDX module architecture specification</a> for official guidance on TDX module interfaces.
For example, for the emulation of the MSRs and CPUIDs virtualization the emulated seam
module does not adhere to the TDX module specification on MSR and CPUID accesses
outlined in section 19 of
<a class="reference external" href="https://www.intel.com/content/dam/develop/external/us/en/documents/tdx-module-1.0-public-spec-v0.931.pdf">Intel TDX module architecture specification</a> Instead it just inserts a #VE event on most of the MSRs
operations and for the CPUID leaves greater than 0x1f or outside of 0x80000000u-0x80000008u
range. The code in arch/x86/kvm/vmx/seam.c: seam_inject_ve() function can be checked
for up-to-date details.</p>
</section>
</section>
<section id="fuzzing-kernel-boot">
<h2>Fuzzing Kernel Boot<a class="headerlink" href="#fuzzing-kernel-boot" title="Permalink to this heading">¶</a></h2>
<p>The majority of input points identified by Smatch analysis and manual audit are
invoked as part of kernel boot.
The invocation of these code paths is usually hard to achieve at runtime
after the kernel has already booted due to absence of re-initialization
paths for many of these kernel subsystems.</p>
<p>We have adopted the <a class="reference external" href="https://github.com/IntelLabs/kAFL">kAFL Fuzzer</a> for effective feedback fuzzing of the Linux
bootstrapping phase. Using a combination of fast VM snapshots and kernel
hooks, kAFL allows flexible harnessing of the relevant kernel
sub-systems, fast recovery from benign error conditions, and automated
reporting of any desired errors and exceptions handlers.</p>
<figure class="align-default" id="id11">
<a class="reference internal image-reference" href="_images/kAFL-overview.png"><img alt="_images/kAFL-overview.png" src="_images/kAFL-overview.png" style="width: 3.48364in; height: 3.73366in;" /></a>
<figcaption>
<p><span class="caption-text">Figure 4. kAFL overview. 1) start of fuzzing (entry to kernel) 2)
fuzzing harness 3) input fuzz buffer from host 4) MSR/PIO/MMIO causes a
#VE 5) the agent injects a value obtained from 6) the input buffer 7)
finally, reporting back the status to the host (crash/hang/ok)</span><a class="headerlink" href="#id11" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<section id="agent">
<h3>Agent<a class="headerlink" href="#agent" title="Permalink to this heading">¶</a></h3>
<p>While kAFL can work based on binary rewrite and traps, the more
flexible approach is to modify the target’s source code. This
implements an agent that directly hooks relevant subsystems and
low-level input functions and feeds fuzzing input. At a high level,
our agent implementation consists of three parts:</p>
<ol class="loweralpha simple">
<li><p><strong>Core agent logic</strong>: This includes fuzzer initialization and helper
functions for logging and debug. The fuzzer is initialized with
tdg_fuzz_enable(), and accepts control input via tdg_fuzz_event()
to start/stop/pause input injection or report an error event.
<a class="reference external" href="https://github.com/IntelLabs/kafl.linux/blob/kafl/fuzz-5.15-3/arch/x86/kernel/kafl-agent.c">https://github.com/IntelLabs/kafl.linux/blob/kafl/fuzz-5.15-3/arch/x86/kernel/kafl-agent.c</a></p></li>
<li><p><strong>Input hooks</strong>: We leverage the tdx_fuzz hooks of in the
guest kernel as defined by <a class="reference internal" href="#simple-fuzzer-hooks">Simple Fuzzer Hooks</a> as well as
virtio16/32/64_to_cpu wrappers for VirtIO DMA input.
When enabled, the fuzzing hooks are implemented to sequentially
consume input from a payload buffer maintained by the agent. Fuzzing
stops when the buffer is fully consumed or other exit conditions are
met.
<a class="reference external" href="https://github.com/IntelLabs/kafl.linux/commit/1e5206fbd6a3050c4b812a826de29982be7a5905">https://github.com/IntelLabs/kafl.linux/commit/1e5206fbd6a3050c4b812a826de29982be7a5905</a></p></li>
<li><p><strong>Exit and reporting hooks</strong>: We added tdx_fuzz_event() calls to
common error handlers such as panic() and kasan_report(), but also
halt_loop() macros etc. Moreover, the printk subsystem has been
modified to log buffers directly via hypercalls. This allows report
error conditions to be returned to the fuzzer and to collect any
diagnostics before immediately restoring the initial snapshot for
next execution.</p></li>
</ol>
</section>
<section id="harnesses-definition">
<h3>Harnesses Definition<a class="headerlink" href="#harnesses-definition" title="Permalink to this heading">¶</a></h3>
<p>Our kAFL agent implements a number of harnesses covering key phases of boot:</p>
<ul class="simple">
<li><p>Early boot process: EARLYBOOT, POST_TRAP, and START_KERNEL</p></li>
<li><p>Subsystem initialization: REST_INIT, DO_BASIC, DOINITCALLS,
DOINITCALLS_PCI, DOINITCALLS_VIRTIO, DOINITCALLS_ACPI, and
DOINITCALLS_LEVEL_X</p></li>
<li><p>Full boot (ends just before dropping to userspace): FULL_BOOT</p></li>
<li><p>Kretprobe-based single function harnesses: VIRTIO_CONSOLE_INIT and
EARLY_PCI_SERIAL_INIT</p></li>
</ul>
<p>The full list of boot harnesses with descriptions is available at
<a class="reference external" href="https://github.com/intel/ccc-linux-guest-hardening/blob/master/docs/boot_harnesses.txt">https://github.com/intel/ccc-linux-guest-hardening/blob/master/docs/boot_harnesses.txt</a></p>
<p>These harnesses are enabled in the guest Linux kernel by setting up the
kernel build configuration parameters in such a way that the desired
harness is enabled. For example, set
CONFIG_TDX_FUZZ_HARNESS_EARLYBOOT=y to enable the EARLYBOOT harness.
When enabled, the kernel will execute a tdx_fuzz_enable() call at the
beginning of the harness and a corresponding end call at the end of the
harness. These calls cause kAFL to take a snapshot at the first fuzzing
input consumed in the harness, and to reset the snapshot once the
execution reaches the end of the harness. The fuzzer will continue
resetting the snapshot in a loop – having it consume different fuzzing
input on each reset – until the fuzzing campaign is terminated.</p>
<p>During the campaign, the fuzzer automatically logs error cases, such as
crashes, sanitizer violations, or timeouts. Detailed (binary edge)
traces and kernel logs can be extracted in post-processing runs
(coverage gathering). To understand the effectiveness of a campaign, we
map achieved code coverage to relevant input code paths identified by
<a class="reference internal" href="#hardening-smatch-report"><span class="std std-ref">Static Analyzer and Code Audit</span></a> (“Smatch matching”).</p>
</section>
<section id="example-workflow">
<h3>Example Workflow<a class="headerlink" href="#example-workflow" title="Permalink to this heading">¶</a></h3>
<p>Running a boot time fuzzing campaign using our kAFL-based setup
typically consists of three stages, namely:</p>
<ol class="arabic">
<li><p><strong>Run fuzzing campaign(s).</strong> Here we run the fuzzing campaign itself.
The duration of the campaign typically depends on which harness is
being used, how much parallelism can be used, etc. We have included a
script (fuzz.sh) that sets up a campaign with some default settings.
Make sure the guest kernel with the kAFL agent is checked out in
~/tdx/linux-guest. Select a harness that you want to use for fuzzing
(in the next examples we will use the DOINITCALLS_LEVEL_4 harness).
Using our fuzz.sh script, you can run a campaign in the following
manner:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./fuzz.sh<span class="w"> </span>full<span class="w"> </span>./linux-guest/
</pre></div>
</div>
<p>This starts a single fuzzing campaign, with the settings specified
in fuzz.sh. You can get a more detailed view of the status of the
campaign using the kafl_gui.py tool:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>kafl_gui.py<span class="w"> </span>/dev/shm/<span class="nv">$USER_tdfl</span>
</pre></div>
</div>
</li>
<li><p><strong>Gather the line coverage.</strong> Once the campaign has run for long
enough, we can extract the code line coverage from the campaign’s
produced fuzzing corpus.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./fuzz.sh<span class="w"> </span>cov<span class="w"> </span>/dev/shm/<span class="nv">$USER</span><span class="se">\_</span>tdfl
</pre></div>
</div>
<p>This produces output files in the /dev/shm/$USER_tdfl/traces
directory, containing information, such as the line coverage (for
example, see the file traces/addr2line.lst).</p>
</li>
<li><p><strong>Match coverage against Smatch report.</strong> Finally, to get an idea of
what the campaign has covered, we provide some functionality to
analyze the obtained line coverage against the Smatch report. Using
the following command, you can generate a file
(traces/smatch_match.lst) containing the lines from the Smatch
report that the current fuzzing campaign has managed to reach. Run
the Smatch analysis using:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./fuzz.sh<span class="w"> </span>smatch<span class="w"> </span>/dev/shm/<span class="nv">$USER_tdfl</span>
</pre></div>
</div>
<p>For a more complete mapping of the PT trace to line coverage, we
have included functionality to augment the line coverage with
information obtained using Ghidra. For example, if you want to make
sure that code lines in in-lined functions are also considered, run
the previous command, but set the environmental variable
USE_GHIDRA=1. E.g.:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">USE_GHIDRA</span><span class="o">=</span><span class="m">1</span><span class="w"> </span>./fuzz.sh<span class="w"> </span>smatch<span class="w"> </span>/dev/shm/<span class="nv">$USER_tdfl</span>
</pre></div>
</div>
</li>
</ol>
<p>We have included a script (<a class="reference external" href="https://github.com/intel/ccc-linux-guest-hardening/blob/master/bkc/kafl/run_experiments.py">run_experiments.py</a>) that automatically runs
these three steps for all the different relevant boot time harnesses.</p>
</section>
<section id="setup-instructions">
<h3>Setup Instructions<a class="headerlink" href="#setup-instructions" title="Permalink to this heading">¶</a></h3>
<p>The full setup instructions for our kAFL-based fuzzing setup can be found at
<a class="reference external" href="https://github.com/intel/ccc-linux-guest-hardening">https://github.com/intel/ccc-linux-guest-hardening</a></p>
</section>
</section>
<section id="fuzzing-kernel-runtime">
<h2>Fuzzing Kernel Runtime<a class="headerlink" href="#fuzzing-kernel-runtime" title="Permalink to this heading">¶</a></h2>
<p>Fuzzing the TD Guest Kernel at runtime is relevant for any code paths that are
not exercised during boot or exercised during runtime with different context.
Finding a way to reliably activate these code paths can be more difficult as an
appropriate <cite>stimulus</cite> must be found. We present multiple options for finding
a stimulus program and then fuzzing untrusted host/VMM inputs in context of that
stimulus.</p>
<section id="fuzzing-stimulus">
<h3>Fuzzing Stimulus<a class="headerlink" href="#fuzzing-stimulus" title="Permalink to this heading">¶</a></h3>
<p>One challenge with TD guest kernel fuzzing is to create an
appropriate stimulus for the fuzzing process, i.e. to find a way to
reliably invoke the desired code paths in the TD guest kernel that
handle an input from the host/VMM. Without such stimulus, it is hard to
create good fuzzing coverage even for the code locations reported by the
Smatch static analyzer. We considered the following options:</p>
<ul class="simple">
<li><p><strong>Write a set of dedicated tests that exercises the desired code
paths</strong>. The obvious downside of this approach is that it is very
labor-intensive and manual. Also, the Smatch static analyzer list of
findings goes well beyond 1500 unique entries; this approach does not
scale since some of the tests might have to be modified manually as
the mainline Linux kernel keeps developing.</p></li>
<li><p><strong>Use existing test suites for kernel subsystems.</strong> This approach
works well for the cases when a certain type of operation is known to
eventually trigger an input from the host/VMM. Examples include Linux
Test Project (LTP), as well as networking and filesystem test suites
(netperf, stress-ng, perf-fuzzer). The challenge here is to identify test programs
that trigger all the desired code paths. <strong>Todo:</strong> put a coverage info +
refer to section for usermode tracing/fuzzing for how to find/test
own stimulus.</p></li>
<li><p><strong>Automatically produced stimulus corpus.</strong> An alternative way of
using existing test suites or creating new ones can be a method that
would programmatically exercise the existing TD guest kernel runtime
code paths and produce a set of programs that allow invocation of the
paths that lead to obtaining an input from the host/VMM. Fortunately,
the Linux kernel has a well-known tool for exercising the kernel in
runtime – Syzkaller fuzzer. While being a fuzzing tool that was
originally created to test the robustness of ring 3 to ring 0
interfaces, Syzkaller fuzzer can be used to automatically generate a
set of stimulus programs once it is modified to understand whenever a
code path that triggers an input from the host/VMM is invoked.
However, the biggest problem with using Syzkaller in this way is to
create a bias towards executing syscalls that would end up consuming
the input from the host/VMM. This remains a direction for future
research.</p></li>
</ul>
</section>
<section id="simple-fuzzer-hooks">
<h3>Simple Fuzzer Hooks<a class="headerlink" href="#simple-fuzzer-hooks" title="Permalink to this heading">¶</a></h3>
<p>This simple fuzzer defines the basic fuzzer structure and the fuzzing
injection input hooks that can be used by more advanced fuzzers (and in
our case, used by the kAFL fuzzer) to supply the fuzzing input to the TD
guest kernel. The fuzzing input is consumed using the tdx_fuzz() function
that is called right after the input has been consumed from the host
using the <strong>TDG.VP.VMCALL</strong> CPU interface.</p>
<p>The fuzzing input that is used by the basic fuzzer is a simple mutation
using random values and shifts of the actual supplied input from the
host/VMM. The algorithm to produce the fuzzing input can be found in
__tdx_fuzz() from arch/x86/kernel/tdx-fuzz.c. The main limitation of
this fuzzing approach is an absence of any feedback during the fuzzing
process, as well as an inability to recover from kernel crashes or
hangs.</p>
<p>The simple fuzzer exposes several statistics and input injection options via
debugfs. <strong>TODO</strong> Refer documentation as part of Linux kernel sources.</p>
</section>
<section id="kf-x-dma-fuzzing">
<h3>KF/x DMA Fuzzing<a class="headerlink" href="#kf-x-dma-fuzzing" title="Permalink to this heading">¶</a></h3>
<section id="overview">
<h4>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h4>
<p>DMA shared memory is designed to be accessible by the host hypervisor to
facilitate fast I/O operations. DMA is setup using the Linux kernel’s
DMA API and the allocated memory regions are then used by various
drivers to facilitate I/O for disk, network, and console connections via
the VirtIO protocol. The goal of using the KF/x fuzzer on these DMA
memory regions is to identify issues in these drivers and the VirtIO
protocol that may lead to security issues.</p>
<p>To fuzz the code that interacts with DMA memory, do the following:</p>
<ol class="arabic simple">
<li><p>Capture VM snapshot when DMA memory read access is performed</p></li>
<li><p>Transfer VM snapshot to KF/x fuzzing host</p></li>
<li><p>Identify stop-point in the snapshot</p></li>
<li><p>Fuzz target using KF/x</p></li>
</ol>
<figure class="align-default" id="id12">
<a class="reference internal image-reference" href="_images/kf-x-overview.png"><img alt="_images/kf-x-overview.png" src="_images/kf-x-overview.png" style="width: 5.86458in; height: 3.29883in;" /></a>
<figcaption>
<p><span class="caption-text">Figure 5. KF/x overview</span><a class="headerlink" href="#id12" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="details">
<h4>Details<a class="headerlink" href="#details" title="Permalink to this heading">¶</a></h4>
<ol class="upperalpha">
<li><p>As the memory underpinning DMA is regular RAM, the guest-physical
address is bound to run through the MMU’s Second Layer Address
Translation via the Extended Page Tables (EPT). This allows us to
restrict the EPT permissions and remove read-access rights from the VM.
By removing EPT access rights of the memory regions designated to be
DMA, the hypervisor gets a page-fault notification of all code-locations
that interact with DMA memory. The <a class="reference external" href="https://github.com/kvm-vmi">Bitdefender KVM VMI
patch-set</a> is used for this
introspection.</p>
<p>DMA regions are identified by hooking the Linux kernel’s DMA API via
hypervisor-level breakpoint injection. By injecting a breakpoint into
the DMA API responsible for mapping and unmapping memory, we can track
which memory pages are designated to be DMA. The VM is booted with this
monitoring enabled from the start and the EPT permissions are
automatically restricted for all pages that are currently DMA mapped.</p>
<p>As DMA accesses are very frequent, the number of snapshots taken are
reduced by observing the call-stack leading to the DMA access. For this,
the kernel is compiled with stack frame pointers enabled. By hashing the
four top-level functions on the call-stack, we identify whether a given
DMA access is performed under a unique context or not (such as a
particular system-call, kernel thread, etc.).</p>
<p>The faulting instruction is then emulated by the hypervisor to allow the
DMA access to continue without the kernel getting stuck trying to access
memory.</p>
</li>
<li><p>Snapshots are transferred to KF/x fuzzing hosts running on Xen.
Snapshots are loaded into VM-shells by transplanting the snapshots’
memory and vCPU context.</p></li>
<li><p>The transplanted snapshot is executed up to a limited number of
instructions (usually between 100k-250k) and logged to a file.
Cross-reference the log with stacktrace to see how far back up the stack
the execution reached. Place a breakpoint at that address.</p></li>
<li><p>KF/x is set up to fuzz the entire DMA page (4096 bytes) where the
memory access was captured. The fuzzer is set to log any fuzzed input
that leads to KASAN, UBSAN, or panic in the VM.</p></li>
</ol>
</section>
<section id="id5">
<h4>Setup instructions<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h4>
<p><a class="reference external" href="https://github.com/intel/kernel-fuzzer-for-xen-project/wiki/Virtio-snapshotting-with-KVM-VMI">Virtio snapshotting with KVM VMI · intel/kernel-fuzzer-for-xen-project
Wiki
(github.com)</a></p>
</section>
</section>
<section id="kafl-stimulus-fuzzing">
<h3>kAFL Stimulus Fuzzing<a class="headerlink" href="#kafl-stimulus-fuzzing" title="Permalink to this heading">¶</a></h3>
<figure class="align-default" id="id13">
<a class="reference internal image-reference" href="_images/kAFL-runtime-overview.png"><img alt="_images/kAFL-runtime-overview.png" src="_images/kAFL-runtime-overview.png" style="width: 3.60417in; height: 3.98958in;" /></a>
<figcaption>
<p><span class="caption-text">Figure 6. kAFL runtime fuzzing overview. 1) start of fuzzing 2)
input fuzz buffer from host 3) stimulus is consumed from userspace
4) MSR/PIO/MMIO causes a #VE 5) the agent injects a value obtained
from 6) the input buffer 7) finally, reporting back the status to
the host (crash/ hang/ ok)</span><a class="headerlink" href="#id13" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The kAFL agent described earlier can also be used to trace and fuzz custom
stimulus programs from userspace. The kAFL setp for userspace fuzzing uses to
following additional components:</p>
<ul class="simple">
<li><p>kAFL agent exposes a userspace interface via debugfs. The interface
offers similar controls to those used to implement boot-time harneses
inside the kernel, i.e. start/stop as well as basic statistics.</p></li>
<li><p>The VM must be started with a valid rootfs, such as an initrd that
contains the stimulus program. The kernel is configured with
CONFIG_TDX_FUZZ_HARNESS_NONE; it boots normally and launches the
designated ‘init’ process. Fuzzer configuration and control is done
via debugfs.</p></li>
<li><p>To avoid managing a large range of filesystems, kAFL offers a
‘sharedir’ option that allows to download files into the guest at
runtime. This way, the rootfs only contains a basic loader while
actual execution is driven by scripts and programs on the Host.
Communication is done using hypercalls and works independently of
virtio or other guest drivers.</p></li>
</ul>
<section id="harness-setup">
<h4>Harness Setup<a class="headerlink" href="#harness-setup" title="Permalink to this heading">¶</a></h4>
<p>As with the other runtime fuzzing setups, the kAFL setup requires an
adequate “stimulus” to trigger kernel code paths that consume data from
the untrusted host/VMM (either using <strong>TDG.VP.VMCALL</strong>-based interface
or virtIO DMA shared memory). We setup kAFL to run any desired userspace
binaries as stimulus input, using a flexible bash script to initialize
snapshotting &amp; stimulus execution from /sbin/init.</p>
<p>The usermode harness that is downloaded and launched by the loader can
be any script or binary and may also act as an intermediate loader or
even compiler of further input. The main difference from regular VM
userspace is that the harness eventually enables the fuzzer, at which
point the kAFL/Qemu frontend creates the initial VM snapshot and
provides a first candidate payload to the kAFL agent. Once the snapshot
loop has started, execution is traced for coverage feedback and the
userspace is fully reset after timeout, crashes, or when the “done”
event is signaled via debugfs.</p>
<p>Example harness using a stimulus.elf program:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="nv">KAFL_CTL</span><span class="o">=</span>/sys/kernel/debug/kafl
hget<span class="w"> </span>stimulus.elf<span class="w"> </span><span class="c1"># fetch test binary from host</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;[*] kAFL agent status:&quot;</span>
grep<span class="w"> </span>.<span class="w"> </span><span class="nv">$KAFL_CTL</span>/*
<span class="c1"># &quot;start&quot; signal initializes agent and triggers snapshot</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;start&quot;</span><span class="w"> </span>&gt;<span class="w"> </span><span class="nv">$KAFL_CTL</span>/control
<span class="c1"># execute the stimulus, redirecting outputs to host hprintf log</span>
./stimulus.elf<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="w"> </span><span class="p">|</span>hcat
<span class="c1"># if we have not crashed, signal &quot;success&quot; and restore snapshot</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;done&quot;</span><span class="w"> </span>&gt;<span class="w"> </span><span class="nv">$KAFL_CTL</span>/control
</pre></div>
</div>
<p>Detailed setup and scripts to generate small rootfs/initrd:
<a class="reference external" href="https://github.com/intel/ccc-linux-guest-hardening/tree/master/bkc/kafl/userspace">https://github.com/intel/ccc-linux-guest-hardening/tree/master/bkc/kafl/userspace</a></p>
<p>More sophisticated “harness” for randomized stimulus execution:
<a class="reference external" href="https://github.com/intel/ccc-linux-guest-hardening/tree/master/bkc/kafl/userspace/sharedir_template/init.sh">https://github.com/intel/ccc-linux-guest-hardening/tree/master/bkc/kafl/userspace/sharedir_template/init.sh</a></p>
</section>
</section>
</section>
<section id="enabling-additional-kernel-drivers">
<h2>Enabling additional kernel drivers<a class="headerlink" href="#enabling-additional-kernel-drivers" title="Permalink to this heading">¶</a></h2>
<p>The reference TDX guest kernel implementation provided for the <a class="reference external" href="https://github.com/intel/tdx-tools">Linux SW stack for
Intel TDX</a> only enables a small set of
virtio drivers that are essential for the TDX guest basic functionality. These
drivers have been hardened using the methodology described in this document,
but naturally different deployment scenarios and use cases for the TDX will
require many more additional drivers to be enabled in the TDX guest kernel.</p>
<p>This section provides guidance on how to use the methodology presented
in this document for adding and hardening a new driver for the TDX guest kernel.</p>
<p>In order to explain better on how to perform the below steps, we will
use virtio-vsock driver as an example. This driver was the last one to
be enabled and hardened
for the <a class="reference external" href="https://github.com/intel/tdx-tools">Linux SW stack for Intel TDX</a>.
Its primary usage in TDX guest kernel is to communicate with the host to
request converting a local TDX attestation report into a remotely verifiable
TDX attestation quote.</p>
<section id="identify-the-device-driver-pair">
<h3>Identify the device/driver pair<a class="headerlink" href="#identify-the-device-driver-pair" title="Permalink to this heading">¶</a></h3>
<p>The first step includes locating the source code of a target driver in
the Linux kernel tree, understanding the bus that this driver
is registered for (typically it would be a pci or acpi bus), as well as
how the driver registration is done, how to perform functional testing
for this driver and any higher-level interface abstractions present.</p>
<p><strong>Example</strong>. For our <code class="code docutils literal notranslate"><span class="pre">virtio-vsock</span></code> driver example, the source code of this
driver is located at <a class="reference external" href="https://github.com/IntelLabs/kafl.linux/blob/kafl/fuzz-5.15-4/net/vmw_vsock/virtio_transport.c">/net/vmw_vsock/virtio_transport.c</a> and the driver
registers itself on the virtio bus (an abstraction level over the pci bus)
using <a class="reference external" href="https://github.com/IntelLabs/kafl.linux/blob/kafl/fuzz-5.15-4/net/vmw_vsock/virtio_transport.c#L754">register_virtio_driver()</a>.</p>
</section>
<section id="perform-code-audit">
<h3>Perform code audit<a class="headerlink" href="#perform-code-audit" title="Permalink to this heading">¶</a></h3>
<p>In this step, the source code of the driver
is manually audited to determine the input points where the untrusted data
from the host or <cite>VMM</cite> is consumed and how this data is being processed.
In order to facilitate the manual audit, the <code class="code docutils literal notranslate"><span class="pre">check_host_input</span></code> smatch pattern can
be used to identify these input points. For that, a smatch run can be done on
an individual driver source file using <code class="code docutils literal notranslate"><span class="pre">kchecker</span></code> command.</p>
<p><strong>Example</strong>. The below command line for <code class="code docutils literal notranslate"><span class="pre">virtio-vsock</span></code> driver assumes
that you have
a smatch instance with the <code class="code docutils literal notranslate"><span class="pre">check_host_input</span></code> pattern installed at
<code class="code docutils literal notranslate"><span class="pre">~/smatch</span></code> folder and the command is invoked from the kernel source tree root.
For the instructions on how to install smatch please consult
<a class="reference external" href="https://github.com/intel/ccc-linux-guest-hardening/blob/master/bkc/audit/README.md">README.md</a></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>~/smatch_scripts/kchecker<span class="w"> </span>net/vmw_vsock/virtio_transport.c<span class="w"> </span>&gt;<span class="w"> </span>driver_results
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">driver_results</span></code> output file will contain the list of input points
and the limited
propagation information:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>net/vmw_vsock/virtio_transport.c:305<span class="w"> </span>virtio_transport_tx_work<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">8890488479003397221</span><span class="o">}</span><span class="w"> </span><span class="s1">&#39;check_host_input&#39;</span><span class="w"> </span><span class="nb">read</span><span class="w"> </span>from<span class="w"> </span>the<span class="w"> </span>host<span class="w"> </span>using<span class="w"> </span><span class="k">function</span>
<span class="s1">&#39;virtqueue_get_buf&#39;</span><span class="w"> </span>to<span class="w"> </span>a<span class="w"> </span>non<span class="w"> </span>int<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="nb">local</span><span class="w"> </span>variable<span class="w"> </span><span class="s1">&#39;pkt&#39;</span>,<span class="w"> </span><span class="nb">type</span><span class="w"> </span>is<span class="w"> </span>struct<span class="w"> </span>virtio_vsock_pkt*<span class="p">;</span>
net/vmw_vsock/virtio_transport.c:306<span class="w"> </span>virtio_transport_tx_work<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">5556237559821482352</span><span class="o">}</span><span class="w"> </span><span class="s1">&#39;check_host_input&#39;</span><span class="w"> </span>propagating<span class="w"> </span>a<span class="w"> </span>tainted<span class="w"> </span>value<span class="w"> </span>from
the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;pkt&#39;</span><span class="w"> </span>into<span class="w"> </span>a<span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="s1">&#39;virtio_transport_free_pkt&#39;</span><span class="p">;</span>
net/vmw_vsock/virtio_transport.c:305<span class="w"> </span>virtio_transport_tx_work<span class="o">()</span><span class="w"> </span>warn:
<span class="o">{</span><span class="m">8890488479003397221</span><span class="o">}</span><span class="w"> </span><span class="s1">&#39;check_host_input&#39;</span><span class="w"> </span>potential<span class="w"> </span><span class="nb">read</span><span class="w"> </span>from<span class="w"> </span>the<span class="w"> </span>host<span class="w"> </span>using
<span class="k">function</span><span class="w"> </span><span class="s1">&#39;virtqueue_get_buf&#39;</span><span class="p">;</span>
net/vmw_vsock/virtio_transport.c:375<span class="w"> </span>virtio_vsock_update_guest_cid<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">7572251756130242</span><span class="o">}</span><span class="w"> </span><span class="s1">&#39;check_host_input&#39;</span><span class="w"> </span>propagating<span class="w"> </span>a<span class="w"> </span>tainted<span class="w"> </span>value<span class="w"> </span>from
the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;guest_cid&#39;</span><span class="w"> </span>into<span class="w"> </span>a<span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="s1">&#39;get&#39;</span><span class="p">;</span>
net/vmw_vsock/virtio_transport.c:377<span class="w"> </span>virtio_vsock_update_guest_cid<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">16638257021812442297</span><span class="o">}</span><span class="w"> </span><span class="s1">&#39;check_host_input&#39;</span><span class="w"> </span>propagating<span class="w"> </span><span class="nb">read</span><span class="w"> </span>value<span class="w"> </span>from
the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;guest_cid&#39;</span><span class="w"> </span>into<span class="w"> </span>a<span class="w"> </span>different<span class="w"> </span>complex<span class="w"> </span>variable<span class="w"> </span><span class="s1">&#39;vsock-&gt;guest_cid&#39;</span><span class="p">;</span>
net/vmw_vsock/virtio_transport.c:410<span class="w"> </span>virtio_transport_event_work<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">8890488479003397221</span><span class="o">}</span><span class="w"> </span><span class="s1">&#39;check_host_input&#39;</span><span class="w"> </span><span class="nb">read</span><span class="w"> </span>from<span class="w"> </span>the<span class="w"> </span>host<span class="w"> </span>using<span class="w"> </span><span class="k">function</span>
<span class="s1">&#39;virtqueue_get_buf&#39;</span><span class="w"> </span>to<span class="w"> </span>a<span class="w"> </span>non<span class="w"> </span>int<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="nb">local</span><span class="w"> </span>variable<span class="w"> </span><span class="s1">&#39;event&#39;</span>,<span class="w"> </span><span class="nb">type</span><span class="w"> </span>is<span class="w"> </span>struct<span class="w"> </span>virtio_vsock_event*<span class="p">;</span>
net/vmw_vsock/virtio_transport.c:412<span class="w"> </span>virtio_transport_event_work<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">8840682050757106252</span><span class="o">}</span><span class="w"> </span><span class="s1">&#39;check_host_input&#39;</span><span class="w"> </span>propagating<span class="w"> </span>a<span class="w"> </span>tainted<span class="w"> </span>value<span class="w"> </span>from
the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;event&#39;</span><span class="w"> </span>into<span class="w"> </span>a<span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="s1">&#39;virtio_vsock_event_handle&#39;</span><span class="p">;</span>
net/vmw_vsock/virtio_transport.c:414<span class="w"> </span>virtio_transport_event_work<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">83481497696856778</span><span class="o">}</span><span class="w"> </span><span class="s1">&#39;check_host_input&#39;</span><span class="w"> </span>propagating<span class="w"> </span>a<span class="w"> </span>tainted<span class="w"> </span>value<span class="w"> </span>from
the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;event&#39;</span><span class="w"> </span>into<span class="w"> </span>a<span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="s1">&#39;virtio_vsock_event_fill_one&#39;</span><span class="p">;</span>
net/vmw_vsock/virtio_transport.c:410<span class="w"> </span>virtio_transport_event_work<span class="o">()</span><span class="w"> </span>warn:
<span class="o">{</span><span class="m">8890488479003397221</span><span class="o">}</span><span class="w"> </span><span class="s1">&#39;check_host_input&#39;</span><span class="w"> </span>potential<span class="w"> </span><span class="nb">read</span><span class="w"> </span>from<span class="w"> </span>the<span class="w"> </span>host
using<span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="s1">&#39;virtqueue_get_buf&#39;</span><span class="p">;</span>
net/vmw_vsock/virtio_transport.c:541<span class="w"> </span>virtio_transport_rx_work<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">8890488479003397230</span><span class="o">}</span><span class="w"> </span><span class="s1">&#39;check_host_input&#39;</span><span class="w"> </span><span class="nb">read</span><span class="w"> </span>from<span class="w"> </span>the<span class="w"> </span>host<span class="w"> </span>using<span class="w"> </span><span class="k">function</span>
<span class="s1">&#39;virtqueue_get_buf&#39;</span><span class="w"> </span>to<span class="w"> </span>a<span class="w"> </span>non<span class="w"> </span>int<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="nb">local</span><span class="w"> </span>variable<span class="w"> </span><span class="s1">&#39;pkt&#39;</span>,<span class="w"> </span><span class="nb">type</span><span class="w"> </span>is<span class="w"> </span>struct<span class="w"> </span>virtio_vsock_pkt*<span class="p">;</span>
net/vmw_vsock/virtio_transport.c:551<span class="w"> </span>virtio_transport_rx_work<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">5556237559821482370</span><span class="o">}</span><span class="w"> </span><span class="s1">&#39;check_host_input&#39;</span><span class="w"> </span>propagating<span class="w"> </span>a<span class="w"> </span>tainted<span class="w"> </span>value<span class="w"> </span>from
the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;pkt&#39;</span><span class="w"> </span>into<span class="w"> </span>a<span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="s1">&#39;virtio_transport_free_pkt&#39;</span><span class="p">;</span>
net/vmw_vsock/virtio_transport.c:556<span class="w"> </span>virtio_transport_rx_work<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">5857033014461230228</span><span class="o">}</span><span class="w"> </span><span class="s1">&#39;check_host_input&#39;</span><span class="w"> </span>propagating<span class="w"> </span>a<span class="w"> </span>tainted<span class="w"> </span>value<span class="w"> </span>from
the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;pkt&#39;</span><span class="w"> </span>into<span class="w"> </span>a<span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="s1">&#39;virtio_transport_deliver_tap_pkt&#39;</span><span class="p">;</span>
net/vmw_vsock/virtio_transport.c:557<span class="w"> </span>virtio_transport_rx_work<span class="o">()</span><span class="w"> </span>error:
<span class="o">{</span><span class="m">8453424129492944817</span><span class="o">}</span><span class="w"> </span><span class="s1">&#39;check_host_input&#39;</span><span class="w"> </span>propagating<span class="w"> </span>a<span class="w"> </span>tainted<span class="w"> </span>value<span class="w"> </span>from
the<span class="w"> </span>host<span class="w"> </span><span class="s1">&#39;pkt&#39;</span><span class="w"> </span>into<span class="w"> </span>a<span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="s1">&#39;virtio_transport_recv_pkt&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>Given this information the manual code audit can be performed by looking at each
reported entry in the source code to determine whenever the input consumed
from host or <cite>VMM</cite> is processed securely. Please consult section <a class="reference internal" href="#static-analyzer-and-code-audit">Static Analyzer and Code Audit</a>
for more information on how to interpret each reported entry and how to perform
manual analysis. The output of this step is a list of entries that are marked
‘concern’ that would require patches to be created in order to harden
the given driver based on the manual code audit step.</p>
</section>
<section id="perform-driver-fuzzing">
<h3>Perform driver fuzzing<a class="headerlink" href="#perform-driver-fuzzing" title="Permalink to this heading">¶</a></h3>
<p>Ideally each code location reported by the smatch
in step 2 needs to be exercised by using either <cite>kafl</cite> or <cite>kfx</cite> fuzzers (or both).
However, if resource or timing is very limited, the fuzzing can be
primary focused
only on the ‘concern’ entries from the step 2 or on any other entries
that are considered potentially problematic (complex parsing of data, many call
chains, etc.).
The typical reported input locations can be divided into two groups:
driver initialization
code (init and probe functions) and runtime operation. The first group would be
the easiest one to reach by a fuzzer since it does not require any
external stimulus:
it only requires a creation of a separate fuzzing harness. The second
one ideally
requires a functional test suite to be run to exercise the driver
functionality as a stimulus.
However, in the absence of such a test suite, a set of simple manual
tests can be
created or certain userspace commands/operations performed that trigger
invocation of the functions reported by smatch in step 2. Setting up
the driver fuzzing can also be very beneficial even in cases when
smatch does not report any hits in driver’s init or probe functions,
because smatch can miss some host input consumption points in some
cases and fuzzing can help discover such cases.</p>
<p><strong>Example</strong>. Enabling fuzzing targets like the <code class="code docutils literal notranslate"><span class="pre">virtio-vsock</span></code> driver
requires some manual work and modifications of the fuzzing setup (as
opposite to more straightforward examples like <code class="code docutils literal notranslate"><span class="pre">virtio-net</span></code> or
<code class="code docutils literal notranslate"><span class="pre">virtio-console</span></code>) and below steps explain how to add support for such a
target. In a nutshell, <code class="code docutils literal notranslate"><span class="pre">virtio-vsock</span></code> sets up a socket on the host or <cite>VMM</cite>,
allowing a host process to setup a direct socket connection to the
guest VM over <cite>VirtIO</cite>. For fuzzing, this requires some initial setup in
the host, as well as establishing a connection from the guest.
It is also important to make sure that the targeted device is allowed
by the device filter when performing the fuzzing. See
<cite>Enable driver in the TDX filter`</cite>  below for the instructions.</p>
<p><strong>Host steps</strong>. First, the <cite>VMM</cite> host kernel must support <code class="code docutils literal notranslate"><span class="pre">VSOCK</span></code>. The
corresponding kernel module can be loaded using <code class="code docutils literal notranslate"><span class="pre">modprobe</span> <span class="pre">vhost_vsock</span></code>.
If this fails, it might be required to install a
different kernel which has <code class="code docutils literal notranslate"><span class="pre">CONFIG_VHOST_VSOCK</span></code> set. When the
<code class="code docutils literal notranslate"><span class="pre">vhost_vsock</span></code> driver is enabled, a device shall appear at
<code class="code docutils literal notranslate"><span class="pre">/dev/vhost-vsock</span></code>. Its default permissions might be insufficient for
<cite>QEMU</cite> to access, but it can be fixed by executing <code class="code docutils literal notranslate"><span class="pre">chmod</span> <span class="pre">0666</span> <span class="pre">/dev/vhost-vsock</span></code>.
Now that the <code class="code docutils literal notranslate"><span class="pre">vhost-vsock</span></code> device is available to
<cite>QEMU</cite>, the device for the guest VM can be enabled by appending the
string <code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=3</span></code> to
QEMU options. The guest-cid value is a connection identifier that
needs to be unique for the system. In other words, when fuzzing with
multiple workers, each <cite>QEMU</cite> instance must use a separate guest-cid.
For kAFL we have added some syntax magic to allow for these
kinds of situations. In your <code class="code docutils literal notranslate"><span class="pre">kafl_config.yaml</span></code> (by default found in
<code class="code docutils literal notranslate"><span class="pre">$BKC_ROOT/bkc/kafl/kafl_config.yaml</span></code>),  the following string can be
appended to the <code class="code docutils literal notranslate"><span class="pre">qemu_base</span></code> entry: <code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid={QEMU_ID</span> <span class="pre">+</span> <span class="pre">3}</span></code>.
The expression <code class="code docutils literal notranslate"><span class="pre">QEMU_ID</span> <span class="pre">+</span> <span class="pre">3</span></code>, will evaluate to the <cite>QEMU</cite> worker instance id
(which is unique) plus 3. We need to add 3, since the vsock guest cid
range starts at 3. <cite>CIDs</cite> 0,1,2 are reserved for the hypervisor,
generally reserved, and reserved for the host respectively. Now each
fuzzing worker instance should get its own unique <cite>CID</cite>, allowing a
connection to be made from the guest to the host. Finally, to be able
to test vsock and setup connections, the <code class="code docutils literal notranslate"><span class="pre">socat</span></code> utility can be used.
While <code class="code docutils literal notranslate"><span class="pre">socat</span></code> can be already installed on your fuzzing system, the socat
vsock support is a recent addition and it might be required to
download or build a more recent version of socat to enable this
functionality. Pre-built binaries and the source code is available at
<cite>socat project page &lt;http://www.dest-unreach.org/socat/&gt;`</cite> To test
whether the installed <code class="code docutils literal notranslate"><span class="pre">socat</span></code> supports vsock execute: <code class="code docutils literal notranslate"><span class="pre">socat</span> <span class="pre">VSOCK-LISTEN:8089,fork</span></code>.</p>
<p>To summarize, these are the main steps to be performed on the host:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>modprobe<span class="w"> </span>vhost_vsock
chmod<span class="w"> </span><span class="m">0666</span><span class="w"> </span>/dev/vhost-vsock
qemu:<span class="w"> </span>-device<span class="w"> </span>vhost-vsock-pci,id<span class="o">=</span>vhost-vsock-pci0,guest-cid<span class="o">=</span><span class="m">3</span>
</pre></div>
</div>
<p><strong>Guest steps</strong>. The next step in enabling <code class="code docutils literal notranslate"><span class="pre">virtio-vsock</span></code> fuzzing is to
set up the kAFL userspace fuzzing harness in the following way.</p>
<p>First, the guest kernel needs to be compiled with <code class="code docutils literal notranslate"><span class="pre">vsock</span></code> support
(<code class="code docutils literal notranslate"><span class="pre">CONFIG_VIRTIO_VSOCKET=y</span></code> and <code class="code docutils literal notranslate"><span class="pre">CONFIG_VHOST_VSOCK=y</span></code>). Alternatively, it
can be also enabled as a kernel module, but this will require an
additional step to load the module later. To make things easier, just
build the drivers as built-in.</p>
<p>Since we have opted to use the socat tool, the socat utility needs to
be enabled in guest’s busybox <code class="code docutils literal notranslate"><span class="pre">initrd.cpio.gz</span></code>. It can be done during
the socat built by either setting <code class="code docutils literal notranslate"><span class="pre">BR2_PACKAGE_SOCAT</span> <span class="pre">/</span></code> in the
<code class="code docutils literal notranslate"><span class="pre">bkc/kafl/userspace/buildroot.config</span></code>, or alternatively in
<code class="code docutils literal notranslate"><span class="pre">$BKC_ROOT/buildroot-2021.11</span></code> use <code class="code docutils literal notranslate"><span class="pre">make</span> <span class="pre">menuconfig</span></code> navigate to the
right menu entry, save the config, and then build using <code class="code docutils literal notranslate"><span class="pre">make</span></code>.</p>
<p>Finally, the following steps will add the correct kAFL userspace
harness. In <code class="code docutils literal notranslate"><span class="pre">$BKC_ROOT/sharedir</span></code>, edit your <code class="code docutils literal notranslate"><span class="pre">init.sh</span></code> to include the
following snippet early in the script:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mount<span class="w"> </span>-t<span class="w"> </span>debugfs<span class="w"> </span>none<span class="w"> </span>/sys/kernel/debug/
<span class="nv">KAFL_CTL</span><span class="o">=</span>/sys/kernel/debug/kafl
<span class="nb">echo</span><span class="w"> </span>“VSOCK<span class="w"> </span>fuzzing<span class="w"> </span>harness”<span class="w"> </span><span class="p">|</span><span class="w"> </span>hcat
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;start&quot;</span><span class="w">  </span>&gt;<span class="w"> </span><span class="nv">$KAFL_CTL</span>/control
socat<span class="w"> </span>-<span class="w"> </span>VSOCK-CONNECT:2:8089
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;done&quot;</span><span class="w">  </span>&gt;<span class="w"> </span><span class="nv">$KAFL_CTL</span>/control
</pre></div>
</div>
<p>Now it should be possible to start up a new <cite>VSOCK</cite> harness by first,
start listening on the host using <code class="code docutils literal notranslate"><span class="pre">socat</span> <span class="pre">VSOCK-LISTEN:8089,fork</span> <span class="pre">–</span></code>,
and then start kAFL (make sure it’s using HARNESS_NONE, as always when
using userspace harnesses) using <code class="code docutils literal notranslate"><span class="pre">fuzz.sh</span> <span class="pre">run</span> <span class="pre">linux-guest</span> <span class="pre">--debug</span> <span class="pre">-p1</span> <span class="pre">--sharedir</span> <span class="pre">sharedir/</span></code>.
You should see the text <code class="code docutils literal notranslate"><span class="pre">VSOCK</span> <span class="pre">fuzzing</span> <span class="pre">harness</span></code>
appear in your kAFL process.</p>
<p>To summarize these steps can be executed to start a <cite>VSOCK</cite> harness:</p>
<p>On the guest:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>socat<span class="w"> </span>VSOCK-LISTEN:8089,fork<span class="w"> </span>–
</pre></div>
</div>
<p>On the host:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>socat<span class="w"> </span>-<span class="w"> </span>vsock-accept:3:8089
</pre></div>
</div>
<p>On the guest:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>socat<span class="w"> </span>-<span class="w"> </span>VSOCK-CONNECT:2:8089
</pre></div>
</div>
<p>On the host:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>socat<span class="w"> </span>VSOCK-LISTEN:8089,fork<span class="w"> </span>–
</pre></div>
</div>
<p>It is also likely that in the above-mentioned setup the kAFL fuzzer
will not make any progress. This is due to the fact that the inputs
are not stable. This happens due to the fact that an external process
is part of the fuzzing setup. If you encounter this issue, you might
need to modify kAFL slightly. In the function <code class="code docutils literal notranslate"><span class="pre">execute()</span></code> in
<code class="code docutils literal notranslate"><span class="pre">$BKC_ROOT/kafl/fuzzer/kafl_fuzzer/worker/worker.py</span></code>, when a value is
assigned to the variable <code class="code docutils literal notranslate"><span class="pre">stable</span></code>, make sure to overwrite this with
True. It is also possible to add a custom command line flag enabling
this feature to the kAFL settings in
<code class="code docutils literal notranslate"><span class="pre">$BKC_ROOT/kafl/fuzzer/kafl_fuzzer/common/config.py</span></code>.</p>
<p>The above example for the <code class="code docutils literal notranslate"><span class="pre">virtio-vsock</span></code> has demonstrated how to enable
fuzzing in a more complex driver setup scenario using a userspace kAFL
harness. The end output of the fuzzing step is a set of reproducible
crashes that a fuzzer finds for the given driver. The crashes needs to
be investigated and the ones that are determined to be real security
issues need to be fixed in the code.</p>
</section>
<section id="perform-code-fixes">
<h3>Perform code fixes<a class="headerlink" href="#perform-code-fixes" title="Permalink to this heading">¶</a></h3>
<p>Based on the above steps 2 and 3, a set of hardening patches
need to be created to fix the identified issues. We strongly encourage to submit
any such hardening patches to the mainline Linux kernel to ensure
everyone benefits
the joint hardened kernel, as well to get suggestions on the most
appropriate way of
fixing these issues. Also in order to verify that the issues have been
addressed by
respective patches, a new round of fuzzing needs to be performed to
verify that the
issues found in step 3 are not reproducible anymore.</p>
</section>
<section id="enable-driver-in-the-tdx-filter">
<h3>Enable driver in the TDX filter<a class="headerlink" href="#enable-driver-in-the-tdx-filter" title="Permalink to this heading">¶</a></h3>
<p>When the driver code has been hardened and all
the patches are integrated and verified, the driver can be enabled in
the TDX guest by modifying
the allow list in the TDX driver filter code in <a class="reference external" href="https://github.com/IntelLabs/kafl.linux/blob/kafl/fuzz-5.15-4/arch/x86/kernel/tdx-filter.c">arch/x86/kernel/tdx-filter.c</a>.</p>
<p><strong>Example</strong>. For the virtio-vsock driver the following patch adds it
to the list of allowed devices on the virtio bus.</p>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span>Vsock driver has been audited, add it to the allow list in the TDX device
filter.

Signed-off-by: Alexander Shishkin &lt;alexander.shishkin@linux.intel.com&gt;
<span class="gs">---</span>
arch/x86/kernel/tdx-filter.c    | 1 +
include/uapi/linux/virtio_ids.h | 1 +
2 files changed, 2 insertions(+)

<span class="gh">diff --git a/arch/x86/kernel/tdx-filter.c b/arch/x86/kernel/tdx-filter.c</span>
<span class="gh">index 47fda826aec4..fd759680bd2a 100644</span>
<span class="gd">--- a/arch/x86/kernel/tdx-filter.c</span>
<span class="gi">+++ b/arch/x86/kernel/tdx-filter.c</span>
<span class="gu">@@ -64,6 +64,7 @@ struct pci_device_id pci_allow_ids[] = {</span>
<span class="w"> </span> { PCI_DEVICE(PCI_VENDOR_ID_REDHAT_QUMRANET, VIRTIO1_ID_BLOCK) },
<span class="w"> </span> { PCI_DEVICE(PCI_VENDOR_ID_REDHAT_QUMRANET, VIRTIO1_ID_CONSOLE) },
<span class="w"> </span> { PCI_DEVICE(PCI_VENDOR_ID_REDHAT_QUMRANET, VIRTIO1_ID_9P) },
<span class="gi">+ { PCI_DEVICE(PCI_VENDOR_ID_REDHAT_QUMRANET, VIRTIO1_ID_VSOCK) },</span>
<span class="w"> </span> { 0, },
};

<span class="gh">diff --git a/include/uapi/linux/virtio_ids.h b/include/uapi/linux/virtio_ids.h</span>
<span class="gh">index a2fcb4681028..f592efd82450 100644</span>
<span class="gd">--- a/include/uapi/linux/virtio_ids.h</span>
<span class="gi">+++ b/include/uapi/linux/virtio_ids.h</span>
<span class="gu">@@ -88,5 +88,6 @@</span>
#define VIRTIO1_ID_BLOCK 0x1042 /* transitional virtio block */
#define VIRTIO1_ID_CONSOLE 0x1043 /* transitional virtio console */
#define VIRTIO1_ID_9P 0x1049 /* transitional virtio 9p console */
<span class="gi">+ #define VIRTIO1_ID_VSOCK 0x1053 /* transitional virtio vsock transport */</span>

#endif /* _LINUX_VIRTIO_IDS_H */
<span class="gd">--</span>
2.25.1
</pre></div>
</div>
</section>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="security-spec.html" class="btn btn-neutral" title="Intel® Trust Domain Extension Linux Guest Kernel Security Specification" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, BSD, MIT, Apache and GPL licenses.
      Last updated on May 27, 2025.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            LANGUAGE:'en',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/documentation_options.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/sphinx_highlight.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>